export interface PLYExportOptions {
  filename?: string
  includeColors?: boolean
  format?: "ascii" | "binary"
  scale?: number
}

export function exportPLY(positions: Float32Array, colors?: Float32Array, options: PLYExportOptions = {}) {
  const { filename = `attractor-${Date.now()}.ply`, includeColors = true, format = "ascii", scale = 1.0 } = options

  const vertexCount = positions.length / 3
  const hasColors = includeColors && colors && colors.length === positions.length

  if (format === "ascii") {
    return exportPLYAscii(positions, colors, vertexCount, hasColors, filename, scale)
  } else {
    return exportPLYBinary(positions, colors, vertexCount, hasColors, filename, scale)
  }
}

function exportPLYAscii(
  positions: Float32Array,
  colors: Float32Array | undefined,
  vertexCount: number,
  hasColors: boolean,
  filename: string,
  scale: number,
) {
  // Build header
  let header = `ply
format ascii 1.0
comment Generated by Chaoscope Clone
element vertex ${vertexCount}
property float x
property float y
property float z`

  if (hasColors) {
    header += `
property uchar red
property uchar green
property uchar blue`
  }

  header += `\nend_header\n`

  // Build vertex data
  let body = ""
  for (let i = 0; i < vertexCount; i++) {
    const x = (positions[i * 3 + 0] * scale).toFixed(6)
    const y = (positions[i * 3 + 1] * scale).toFixed(6)
    const z = (positions[i * 3 + 2] * scale).toFixed(6)

    if (hasColors && colors) {
      const r = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 0] || 0) * 255)))
      const g = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 1] || 0) * 255)))
      const b = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 2] || 0) * 255)))
      body += `${x} ${y} ${z} ${r} ${g} ${b}\n`
    } else {
      body += `${x} ${y} ${z}\n`
    }
  }

  // Create and download file
  const content = header + body
  const blob = new Blob([content], { type: "text/plain" })
  downloadBlob(blob, filename)

  return {
    success: true,
    vertexCount,
    fileSize: blob.size,
    hasColors,
  }
}

function exportPLYBinary(
  positions: Float32Array,
  colors: Float32Array | undefined,
  vertexCount: number,
  hasColors: boolean,
  filename: string,
  scale: number,
) {
  // Build header
  let header = `ply
format binary_little_endian 1.0
comment Generated by Chaoscope Clone
element vertex ${vertexCount}
property float x
property float y
property float z`

  if (hasColors) {
    header += `
property uchar red
property uchar green
property uchar blue`
  }

  header += `\nend_header\n`

  // Calculate buffer size
  const headerBytes = new TextEncoder().encode(header)
  const vertexSize = hasColors ? 15 : 12 // 3 floats (12 bytes) + optional 3 uchars (3 bytes)
  const dataSize = vertexCount * vertexSize
  const totalSize = headerBytes.length + dataSize

  // Create binary buffer
  const buffer = new ArrayBuffer(totalSize)
  const view = new DataView(buffer)
  const uint8View = new Uint8Array(buffer)

  // Write header
  uint8View.set(headerBytes, 0)
  let offset = headerBytes.length

  // Write vertex data
  for (let i = 0; i < vertexCount; i++) {
    // Write position (3 floats, little endian)
    view.setFloat32(offset, positions[i * 3 + 0] * scale, true)
    view.setFloat32(offset + 4, positions[i * 3 + 1] * scale, true)
    view.setFloat32(offset + 8, positions[i * 3 + 2] * scale, true)
    offset += 12

    if (hasColors && colors) {
      // Write color (3 uchars)
      const r = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 0] || 0) * 255)))
      const g = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 1] || 0) * 255)))
      const b = Math.floor(Math.min(255, Math.max(0, (colors[i * 3 + 2] || 0) * 255)))

      view.setUint8(offset, r)
      view.setUint8(offset + 1, g)
      view.setUint8(offset + 2, b)
      offset += 3
    }
  }

  // Create and download file
  const blob = new Blob([buffer], { type: "application/octet-stream" })
  downloadBlob(blob, filename)

  return {
    success: true,
    vertexCount,
    fileSize: blob.size,
    hasColors,
  }
}

function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob)
  const a = document.createElement("a")
  a.href = url
  a.download = filename
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

export function estimatePLYFileSize(vertexCount: number, hasColors: boolean, format: "ascii" | "binary"): number {
  const headerSize = 150 // Approximate header size

  if (format === "ascii") {
    // Each vertex: "x.xxxxxx y.yyyyyy z.zzzzzz" (about 24 chars) + optional " r g b" (about 8 chars) + newline
    const avgLineSize = hasColors ? 33 : 25
    return headerSize + vertexCount * avgLineSize
  } else {
    // Binary: 3 floats (12 bytes) + optional 3 uchars (3 bytes)
    const vertexSize = hasColors ? 15 : 12
    return headerSize + vertexCount * vertexSize
  }
}
